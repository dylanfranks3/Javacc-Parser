PARSER_BEGIN(Assignment)

import java.util.*; //library import
import java.util.regex.Pattern;
import java.util.regex.Matcher;


public class Assignment {
    private static boolean mainDefined = false; //checking whether there is a main function, to make sure only defined once, and importantly defined

    public static void main(String[] args) throws ParseException, TokenMgrError {
            try{
                Assignment parser = new Assignment(System.in);
                parser.Start();

                System.out.println("PASS");
                System.out.println("TODO show result");
            }

            catch (Throwable t){
                System.out.println("FAIL");
                String errorMessage = "Unknown pass error";
                int lineNo = 0;
                
                try {
                // Check which throwable was passed and output the apropriate error message
                     throw t;
                } 

                catch(ParseException e) {
                    errorMessage = intepretParseException(e); // passing the javacc error message into the intepreter to get a more granular result
                    lineNo = e.currentToken.beginLine; // getting the line no of the token
                } 

                catch(TokenMgrError e) {
                    Matcher matcher = Pattern.compile("line \\d+").matcher(e.getMessage());
                    if (matcher.find())
                        lineNo = Integer.parseInt(matcher.group().replace("line ", ""));

                    errorMessage = "Illegal symbol"; 
                }

                catch(CustomErrorMessage e) { // this is a custom error message thrown at run-time when dealing with grammer like if the main function is defined or parameters being consistent
                    errorMessage = e.getMessage(); // custom class method
                    lineNo = e.getLine(); // custom class method
                } 

                System.err.println(lineNo);
                System.err.println(errorMessage);
        
            // Catching Throwable is ugly but JavaCC throws Error objects!
            }
    }

        private static String intepretParseException(ParseException e) { // given a parse exception, take the token and give a helpful string representation of the error
            String str = e.currentToken.image + e.currentToken.next.image + "...";
            int thisToken = e.currentToken.kind;
            int nextToken = e.currentToken.next.kind;

            // Form the set of expected token kinds
            Set<Integer> expected = new HashSet();
            for (int[] i : e.expectedTokenSequences) {
                expected.add(i[0]);
            }


            // Determine an appropriate error message from the caught
            // tokens via case analysis

            if (nextToken == SPACE){
                if (thisToken == SPACE){
                    return "Cannot have consecutive spaces, invalid space";
                }
                else{
                  return "Unexpected space";
                }
            }

            if (expected.contains(DEF))
                return "Missing keyword DEF";

            if (expected.contains(SPACE)) {
                switch (nextToken) {
                    case LBRACE:
                    case RBRACE:
                    case SEMICOLON:
                    case EOL:
                    case EOF:
                        return "Missing whitespace";
                }
            }

            if (expected.contains(FUNCNAME) && expected.contains(MAIN)) {
                if (nextToken == DEF)
                    return "DEF is not a valid function name";

                return "Missing function name";
            }

            if ((thisToken == FUNCNAME || thisToken == MAIN) && expected.contains(SPACE))
                return "Invalid function name " + str;

            if (expected.contains(PARAM) && expected.size() == 1)
                return "Missing parameter name";

            if (thisToken == PARAM) {
                if (expected.contains(SPACE) && expected.size() == 1) {
                    return "Invalid parameter name " + str;
                } else {
                    return "Invalid parameter reference " + str;
                }
            }

            if (expected.contains(LBRACE)) {
                if (nextToken == PARAM) {
                    return "MAIN definition should have no parameter";
                } else {
                    return "Missing {";
                }
            }

            if (thisToken == FUNCNAME && expected.contains(LBRACKET))
                return "Invalid function call " + str;

            if (expected.contains(NUM) && expected.contains(PARAM) && expected.contains(FUNCNAME)) {
                if (nextToken == MAIN)
                    return "Invalid call, MAIN cannot be called in a function expression";

                if (thisToken == LBRACKET) {
                    return "Invalid use of left bracket, only to be used with a function call";

                } else if (thisToken == SPACE) {
                    switch (nextToken) {
                        case RBRACE:
                        case EOL:
                        case EOF:
                            return "Function definition missing expression";
                
                    }
                }
            }

            switch (thisToken) {
                case NUM:
                case PARAM:
                case FUNCNAME:
                    if (nextToken == PLUS || nextToken == MULT) {
                        return "Missing operand " + str;
                    }
            }

            if (expected.contains(RBRACKET))
                return "Missing a )";

            if (expected.contains(RBRACE))
                return "Missing a }";

            if (expected.contains(SEMICOLON))
                return "Missing a;";

            switch (nextToken) {
                case EOL:
                    return "Unexpected new line";
                case EOF:
                    return "Unexpected end of file";
            }

            System.out.println("\n" + "thisToken: " + thisToken + "\n" + "nextToken: " + nextToken + "\n" + "Expected: " + expected.toString() + "\n");
            return "Unknown error";

    }
}

class CustomErrorMessage extends Exception {
    private String message;
    private int line;
   
    // Constructor, not really 
    public CustomErrorMessage(String givenMessage, int givenLine) {
        message =  givenMessage;
        line =  givenLine;
    }

    public String getMessage() {
        return message;
    }

    public int getLine() {
        return line;
    }
}

    
PARSER_END(Assignment)


TOKEN: { 
      <LBRACKET: ("(")> 
    | <RBRACKET: (")")> 
    | <LBRACE: ("{")> 
    | <RBRACE: ("}")> 
    | <SEMICOLON: (";")> 
    | <DEF: ("DEF") >
    | <MAIN: ("MAIN")> 
    | <NUM: ((["1"-"9"])+(["0"-"9"])*) | "0">  //either a 0 or a positive number number 
    | <PLUS: ("+")> 
    | <MULT: ("*")> 
    | <SPACE: (" ")> 
    | <FUNCNAME: (["A"-"Z"])+> 
    | <PARAM: (["a"-"z"])+> 
    | < EOL: "\n" > }
    


void Start() throws ParseException,CustomErrorMessage:{}

{ splitLines() <EOF> End()

 }
    
void splitLines() throws ParseException,CustomErrorMessage:{} //this is to be able to separate each line and determine whether it's a main func of general func (mf/gf resp.)
{
    (<DEF> <SPACE> WHICHFUNC() <SPACE> <SEMICOLON> <EOL>)+
}
    
void WHICHFUNC() throws ParseException,CustomErrorMessage:{} //determining whether the line is a function def or a main def
{
   LOOKAHEAD(2)   GF() |  MF()
}

void MF() throws ParseException, CustomErrorMessage:{} //grammar for the main function
{
    {   
        if (mainDefined) {
            throw new ParseException("Main function can only be defined once");
        } else {
            mainDefined = true;
        }
    }
    <MAIN> <SPACE> <LBRACE> <SPACE> EXPMAIN() <SPACE> <RBRACE>
}

void GF() throws ParseException, CustomErrorMessage:{Token param;} //grammar for a general function
{
    <FUNCNAME> <SPACE> 
    param = <PARAM>
    <SPACE> <LBRACE> <SPACE> EXP(param) <SPACE> <RBRACE>

  
}

void EXP(Token p) throws ParseException, CustomErrorMessage :{Token exactParam;  }  //this is whatever can be within the braces of func definition, the body of a function declaration. TODO, the body must contain parameters called in fun

    
{ 

    (FUNCCALL(p) | <NUM> | exactParam = <PARAM>
    
    {if (!(exactParam.image).equals(p.image)){
        throw new CustomErrorMessage("Expected parameter " + p.image + ", was given, " + exactParam.image + " ", exactParam.beginLine);
    }}
    )

    
    ( (<MULT> | <PLUS>) ( FUNCCALL(p) | <NUM> | exactParam = <PARAM> 

    {if (!(exactParam.image).equals(p.image)){ //checking the passed parameter is the same as the one mentioned in the func def
        throw new CustomErrorMessage("Expected parameter was: " + p.image + ", was given: " + exactParam.image, exactParam.beginLine);
    }}
    ))*



}

void EXPMAIN() throws ParseException,CustomErrorMessage:{}  //this is whatever can be within the braces of func definition, the body of a function declaration. TODO, the body must contain parameters called in fun
{
    (FUNCCALLMAIN() | <NUM> )
    ( (<MULT> | <PLUS>) ( FUNCCALLMAIN() | <NUM> ))*
}

void FUNCCALL(Token p) throws ParseException,CustomErrorMessage:{} //this the syntax of a call to a function, which would be within the body of a function decl i.e foo(bar()*5)) 
{
    <FUNCNAME> <LBRACKET> EXP(p) <RBRACKET>

}

void FUNCCALLMAIN() throws ParseException,CustomErrorMessage:{} //this the syntax of a call to a main function, which would be within the body of a function decl i.e foo(bar()*5)) 
{
    <FUNCNAME> <LBRACKET> EXPMAIN() <RBRACKET>
}

void End () throws ParseException,CustomErrorMessage:{}{
    {if (!mainDefined) {
        throw new ParseException("Missing MAIN function\n0");
        }
    }
}