PARSER_BEGIN(Assignment)

import java.util.*; //library import
import java.util.regex.Pattern;
import java.util.regex.Matcher;


public class Assignment {
    private static boolean mainDefined = false; //checking whether there is a main function, to make sure only defined once, and importantly defined

    public static void main(String[] args) throws ParseException, TokenMgrError {
            try{
                Assignment parser = new Assignment(System.in);
                parser.Start();

                System.out.println("PASS");
                System.out.println("TODO show result");
                }

            catch (Throwable t){

                System.out.println("FAIL");
                String errorMessage = "Unknown pass error";
                int lineNo = 0;
                
                try {
                // Check which throwable was passed and output the apropriate error message
                     throw t;
                } 

            //    catch (PLMParseException e) {
            //        //TODO
            //        System.err.println(lineNo);
            //        System.err.println(errorMessage);    
            //        ;
            //    } 

                catch(ParseException e) {
                    //TODO
                    
           //         lineNo = e.currentToken.next.beginLine;
           //         errorMessage = e.getLocalizedMessage();
                    //System.err.println(exceptionManager.toString());
                    errorMessage = intepretParseException(e);
                    System.err.println(errorMessage); 
                    System.err.println(e.currentToken.beginLine);
                } 

                catch(TokenMgrError e) {
                    Matcher matcher = Pattern.compile("line \\d+").matcher(e.getMessage());
                    if (matcher.find())
                        lineNo = Integer.parseInt(matcher.group().replace("line ", ""));

                    errorMessage = "Illegal symbol";

                    System.err.println(lineNo);
                    System.err.println(errorMessage);    
                }

            
            // Catching Throwable is ugly but JavaCC throws Error objects!
            }
        }

        private static String intepretParseException(ParseException e) { // given a parse exception, take the token and give a helpful string representation of the error
            int at = e.currentToken.kind;
            int found = e.currentToken.next.kind;
            String str = e.currentToken.image + e.currentToken.next.image + "...";

            // Form the set of expected token kinds
            Set<Integer> expected = new HashSet();
            for (int[] i : e.expectedTokenSequences) {
                expected.add(i[0]);
            }

            // Determine an appropriate error message from the caught
            // tokens via case analysis

            if (found == SPACE)
                return "Unexpected space";

            if (expected.contains(DEF))
                return "Missing keyword DEF";

            if (expected.contains(SPACE)) {
                switch (found) {
                    case LBRACE:
                    case RBRACE:
                    case SEMICOLON:
                    case EOL:
                    case EOF:
                        return "Missing whitespace";
                }
            }

            if (expected.contains(FUNCNAME) && expected.contains(MAIN)) {
                if (found == DEF)
                    return "DEF is not a valid function name";

                return "Missing function name";
            }

            if ((at == FUNCNAME || at == MAIN) && expected.contains(SPACE))
                return "Invalid function name " + str;

            if (expected.contains(PARAM) && expected.size() == 1)
                return "Missing parameter name";

            if (at == PARAM) {
                if (expected.contains(SPACE) && expected.size() == 1) {
                    return "Invalid parameter name " + str;
                } else {
                    return "Invalid parameter reference " + str;
                }
            }

            if (expected.contains(LBRACE)) {
                if (found == PARAM) {
                    return "MAIN definition should have no parameter";
                } else {
                    return "Missing {";
                }
            }

            if (at == FUNCNAME && expected.contains(LBRACKET))
                return "Invalid function call " + str;

            if (expected.contains(NUM) && expected.contains(PARAM) && expected.contains(FUNCNAME)) {
                if (found == MAIN)
                    return "Invalid call, MAIN cannot be called in a function expression";

                if (at == LBRACKET) {
                    return "Invalid use of left bracket, only to be used with a function call";

                } else if (at == SPACE) {
                    switch (found) {
                        case RBRACE:
                        case EOL:
                        case EOF:
                            return "Function definition missing expression";
                
                    }
                }
            }

            switch (at) {
                case NUM:
                case PARAM:
                case FUNCNAME:
                    if (found == PLUS || found == MULT) {
                        return "Missing operand " + str;
                    }
            }

            if (expected.contains(RBRACKET))
                return "Missing a )";

            if (expected.contains(RBRACE))
                return "Missing a }";

            if (expected.contains(SEMICOLON))
                return "Missing a;";

            switch (found) {
                case EOL:
                    return "Unexpected new line";
                case EOF:
                    return "Unexpected end of file";
            }

            System.out.println("\n" + "At: " + at + "\n" + "Found: " + found + "\n" + "Expected: " + expected.toString() + "\n");
            return "Unknown error";

    }
}
    
PARSER_END(Assignment)


TOKEN: { 
      <LBRACKET: ("(")> 
    | <RBRACKET: (")")> 
    | <LBRACE: ("{")> 
    | <RBRACE: ("}")> 
    | <SEMICOLON: (";")> 
    | <DEF: ("DEF") >
    | <MAIN: ("MAIN")> 
    | <NUM: ((["1"-"9"])+(["0"-"9"])*) | "0">  //either a 0 or a positive number number 
    | <PLUS: ("+")> 
    | <MULT: ("*")> 
    | <SPACE: (" ")> 
    | <FUNCNAME: (["A"-"Z"])+> 
    | <PARAM: (["a"-"z"])+> 
    | < EOL: "\n" > }
    


void Start() throws ParseException:{}

{ splitLines() <EOF> End()

 }
    
void splitLines() throws ParseException:{} //this is to be able to separate each line and determine whether it's a main func of general func (mf/gf resp.)
{
    (<DEF> <SPACE> WHICHFUNC() <SPACE> <SEMICOLON> <EOL>)+
}
    
void WHICHFUNC() throws ParseException:{} //determining whether the line is a function def or a main def
{
   LOOKAHEAD(2)   GF() |  MF()
}

void MF() throws ParseException:{} //grammar for the main function
{
    {   
        if (mainDefined) {
            throw new ParseException("Main function can only be defined once");
        } else {
            mainDefined = true;
        }
    }
    <MAIN> <SPACE> <LBRACE> <SPACE> EXPMAIN() <SPACE> <RBRACE>
}

void GF() throws ParseException:{Token param;} //grammar for a general function
{
    <FUNCNAME> <SPACE> 
    param = <PARAM>
    <SPACE> <LBRACE> <SPACE> EXP(param) <SPACE> <RBRACE>

  
}

void EXP(Token p) throws ParseException:{Token exactParam;  }  //this is whatever can be within the braces of func definition, the body of a function declaration. TODO, the body must contain parameters called in fun

    
{ 

    (FUNCCALL(p) | <NUM> | exactParam = <PARAM>
    
    {if (!(exactParam.image).equals(p.image)){
        throw new ParseException("Expected parameter " + p.image + ", was given, " + exactParam.image + " ");
    }}
    )

    
    ( (<MULT> | <PLUS>) ( FUNCCALL(p) | <NUM> | exactParam = <PARAM> 

    {if (!(exactParam.image).equals(p.image)){ //checking the passed parameter is the same as the one mentioned in the func def
        throw new ParseException("Expected parameter was: " + p.image + ", was given: " + exactParam.image);
    }}
    ))*



}

void EXPMAIN() throws ParseException:{}  //this is whatever can be within the braces of func definition, the body of a function declaration. TODO, the body must contain parameters called in fun
{
    (FUNCCALLMAIN() | <NUM> )
    ( (<MULT> | <PLUS>) ( FUNCCALLMAIN() | <NUM> ))*
}

void FUNCCALL(Token p) throws ParseException:{} //this the syntax of a call to a function, which would be within the body of a function decl i.e foo(bar()*5)) 
{
    <FUNCNAME> <LBRACKET> EXP(p) <RBRACKET>

}

void FUNCCALLMAIN() throws ParseException:{} //this the syntax of a call to a main function, which would be within the body of a function decl i.e foo(bar()*5)) 
{
    <FUNCNAME> <LBRACKET> EXPMAIN() <RBRACKET>
}

void End () throws ParseException:{}{
    {if (!mainDefined) {
        throw new ParseException("Missing MAIN function\n0");
        }
    }
}