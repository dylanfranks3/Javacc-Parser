PARSER_BEGIN(Assignment)

import java.util.*; //library import
import java.util.regex.Pattern;
import java.util.regex.Matcher;


public class Assignment {
    private static boolean mainDefined = false; //checking whether there is a main function, to make sure only defined once, and importantly defined

    public static void main(String[] args) throws ParseException, TokenMgrError {
            try{
                Assignment parser = new Assignment(System.in);
                parser.Start();

                System.out.println("PASS");
                System.out.println("TODO show result");
            }

            catch (Throwable t){
                System.out.println("FAIL");
                String errorMessage = "Unknown pass error";
                int lineNo = 0;
                
                try {
                // Check which throwable was passed and output the apropriate error message
                     throw t;
                } 

                catch(ParseException e) {
                    errorMessage = intepretParseException(e); // passing the javacc error message into the intepreter to get a more granular result
                    lineNo = e.currentToken.beginLine; // getting the line no of the token
                } 

                catch(TokenMgrError e) {
                    Matcher matcher = Pattern.compile("line \\d+").matcher(e.getMessage());
                    if (matcher.find())
                        lineNo = Integer.parseInt(matcher.group().replace("line ", ""));

                    errorMessage = "Illegal symbol"; 
                }

                catch(CustomErrorMessage e) { // this is a custom error message thrown at run-time when dealing with grammer like if the main function is defined or parameters being consistent
                    errorMessage = e.getMessage(); // custom class method
                    lineNo = e.getLine(); // custom class method
                } 

                
                System.err.println(errorMessage);
                System.err.println(lineNo);
        
            // Catching Throwable is ugly but JavaCC throws Error objects!
            }
    }

        private static String intepretParseException(ParseException e) { // given a parse exception, take the token and give a helpful string representation of the error
            String str = e.currentToken.image + e.currentToken.next.image;
            int thisToken = e.currentToken.kind;
            int nextToken = e.currentToken.next.kind;

            System.out.println(str);
            // Form the set of expected token kinds
            Set<Integer> expected = new HashSet();
            for (int[] i : e.expectedTokenSequences) {
                expected.add(i[0]);
            }

            System.out.println("\n" + "thisToken: " + thisToken + "\n" + "nextToken: " + nextToken + "\n" + "Expected: " + expected.toString() + "\n");

            // Determine an appropriate error message from the caught
            // tokens via case analysis
            if (thisToken == SPACE && nextToken == EOL)
                return "Unexpected EOL";


            if (nextToken == SPACE){
                if (thisToken == SPACE){
                    return "Cannot have consecutive spaces, invalid space";
                }
                else{
                  return "Unexpected space";
                }
            }

            if (expected.contains(DEF))
                if (thisToken == EOF && nextToken == EOF)
                    return "Empty input";
                else
                    return "Missing keyword DEF";

            if (( thisToken == FUNCNAME) && expected.contains(SPACE) && nextToken != SPACE)
                return "Incorrect defintion of function, correct the formatting of the function name, instead recieved: " + str;

            if ((thisToken == MAIN ) && expected.contains(SPACE) && nextToken != SPACE)
                return "Incorrect defintion of MAIN, correct the formatting of the function name, instead recieved: " + str;
/*

            if (expected.contains(SPACE)) {
                switch (nextToken) {
                    case LBRACE:
                    case RBRACE:
                    case SEMICOLON:
                    case EOL:
                    case EOF:
                        return "Missing whitespace";
                }
            }

            */

            if (expected.contains(MAIN) && expected.contains(FUNCNAME)) {
                if (nextToken == DEF)
                    return "Cannot use DEF as a function name";

                return "Missing function name";
            }
            if ((thisToken == NUM || thisToken == PARAM ) && (expected.contains(PLUS) && expected.contains(MULT) && expected.contains(SPACE)))
                return "Invalid expression inside function definition, expected an operation or an ending of the function definition, was given: " + str;

            if ((thisToken == MULT || thisToken == PLUS ) && (expected.contains(PARAM) && expected.contains(SPACE) && expected.contains(FUNCNAME)))
                return "Invalid expression next to operation inside function definition, was given: " + str;
                 

            if ((thisToken == FUNCNAME || thisToken == MAIN) && expected.contains(SPACE))
                return "Invalid function name " + str;

            if (expected.contains(PARAM) && expected.size() == 1)
                return "Missing parameter name";

            if (thisToken == PARAM) {
                if (expected.contains(SPACE) && expected.size() == 1) {
                    return "Invalid parameter name " + str;
                } else {
                    return "Invalid parameter reference " + str;
                }
            }

            if (expected.contains(LBRACE)) {
                if (nextToken == PARAM) {
                    return "MAIN definition should have no parameter";
                } else {
                    return "Missing {";
                }
            }

            if (thisToken == FUNCNAME && expected.contains(LBRACKET))
                return "Invalid function call " + str;

            if (expected.contains(NUM) && expected.contains(PARAM) && expected.contains(FUNCNAME)) {
                if (nextToken == MAIN)
                    return "Invalid call, MAIN cannot be called in a function expression";

                if (thisToken == LBRACKET) {
                    return "Invalid use of left bracket, only to be used with a function call";

                } else if (thisToken == SPACE) {
                    switch (nextToken) {
                        case EOF:
                            return "Function definition missing expression";
                
                    }
                }
            }

            switch (thisToken) {
                case FUNCNAME:
                    if (nextToken == PLUS || nextToken == MULT) {
                        return "Missing operand " + str;
                    }
            }

            if (expected.contains(RBRACKET))
                return "Missing a ) ";

            if (expected.contains(RBRACE))
                return "Expecting a } and instead recieved: " + str;

            if (expected.contains(SEMICOLON))
                return "Expecting a ; and instead recieved: " + str;

            switch (nextToken) {
                case EOL:
                    return "Unexpected new line";
                case EOF:
                    return "Unexpected end of file";
            }

            
            return "Unknown error";

    }
}

class CustomErrorMessage extends Throwable {
    private String message;
    private int line;
   
    // Constructor, not really 
    public CustomErrorMessage(String givenMessage, int givenLine) {
        message =  givenMessage;
        line =  givenLine;
    }

    public String getMessage() {
        return message;
    }

    public int getLine() {
        return line;
    }
}

    
PARSER_END(Assignment)


TOKEN: { 
      <LBRACKET: ("(")> 
    | <RBRACKET: (")")> 
    | <LBRACE: ("{")> 
    | <RBRACE: ("}")> 
    | <SEMICOLON: (";")> 
    | <DEF: ("DEF") >
    | <MAIN: ("MAIN")> 
    | <NUM: ((["1"-"9"])+(["0"-"9"])*) | "0">  //either a 0 or a positive number number 
    | <PLUS: ("+")> 
    | <MULT: ("*")> 
    | <SPACE: (" ")> 
    | <FUNCNAME: (["A"-"Z"])+> 
    | <PARAM: (["a"-"z"])+> 
    | < EOL: "\n" > }
    


void Start() throws ParseException,CustomErrorMessage:{}

{ splitLines() <EOF> End()

 }
    
void splitLines() throws ParseException,CustomErrorMessage:{} //this is to be able to separate each line and determine whether it's a main func of general func (mf/gf resp.)
{
    (<DEF> <SPACE> (<MAIN> MF() | <FUNCNAME> GF()) <SPACE> <SEMICOLON> <EOL>)+
}
    
void WHICHFUNC() throws ParseException,CustomErrorMessage:{} //determining whether the line is a function def or a main def
{
   LOOKAHEAD(2)   GF() |  MF()
}

void GF() throws ParseException, CustomErrorMessage:{Token param;} //grammar for a general function
{
    <SPACE> 
    param = <PARAM>
    <SPACE> <LBRACE> <SPACE> EXP(param) <SPACE> <RBRACE>

  
}

void MF() throws ParseException, CustomErrorMessage:{} //grammar for the main function
{
    {   
        if (mainDefined) {
            throw new ParseException("Main function can only be defined once");
        } else {
            mainDefined = true;
        }
    }
    <SPACE> <LBRACE> <SPACE> EXPMAIN() <SPACE> <RBRACE>
}



void EXP(Token p) throws ParseException, CustomErrorMessage :{Token exactParam;  }  //this is whatever can be within the braces of func definition, the body of a function declaration. TODO, the body must contain parameters called in fun

    
{ 

    (FUNCCALL(p) | <NUM> | exactParam = <PARAM>
    
    {if (!(exactParam.image).equals(p.image)){
        throw new CustomErrorMessage("Expected parameter " + p.image + ", was given, " + exactParam.image + " ", exactParam.beginLine);
    }}
    )

    
    ( (<MULT> | <PLUS>) ( FUNCCALL(p) | <NUM> | exactParam = <PARAM> 

    {if (!(exactParam.image).equals(p.image)){ //checking the passed parameter is the same as the one mentioned in the func def
        throw new CustomErrorMessage("Expected parameter was: " + p.image + ", was given: " + exactParam.image, exactParam.beginLine);
    }}
    ))*



}

void EXPMAIN() throws ParseException,CustomErrorMessage:{}  //this is whatever can be within the braces of func definition, the body of a function declaration. TODO, the body must contain parameters called in fun
{
    (FUNCCALLMAIN() | <NUM> )
    ( (<MULT> | <PLUS>) ( FUNCCALLMAIN() | <NUM> ))*
}

void FUNCCALL(Token p) throws ParseException,CustomErrorMessage:{} //this the syntax of a call to a function, which would be within the body of a function decl i.e foo(bar()*5)) 
{
    <FUNCNAME> <LBRACKET> EXP(p) <RBRACKET>

}

void FUNCCALLMAIN() throws ParseException,CustomErrorMessage:{} //this the syntax of a call to a main function, which would be within the body of a function decl i.e foo(bar()*5)) 
{
    <FUNCNAME> <LBRACKET> EXPMAIN() <RBRACKET>
}

void End () throws ParseException,CustomErrorMessage:{}{
    {if (!mainDefined) {
        throw new CustomErrorMessage("Missing MAIN function",0);
        }
    }
}