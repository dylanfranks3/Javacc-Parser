/* Assignment.java */
/* Generated By:JavaCC: Do not edit this line. Assignment.java */
import java.util.*; //library import
import java.io.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Assignment implements AssignmentConstants {
    private static boolean mainDefined = false; //checking whether there is a main function, to make sure only defined once, and importantly defined
    public static void main(String[] args) throws ParseException, TokenMgrError {
            try{
                Scanner in = new Scanner(System.in);
                String s = "";
                ArrayList<String> eachLine = new ArrayList<String>(); // for evaluating the functions later
                while (in.hasNextLine()) {
                    String nL = in.nextLine();
                    s = s  + nL + "\n" ;
                    eachLine.add(nL);
                }

                InputStream is = new ByteArrayInputStream( s.getBytes() ); // parse it back into an INPUTstream
                Assignment parser = new Assignment(is); // give whatever is inputted to the parser
                parser.Start(); // start the grammer checking

                // now the evaluation
                int count = 1; // which line the function deifinition is on
                Evaluater assigmentEval = new Evaluater();
                for (String i : eachLine){
                    String line = i.substring(4); // cutting out the def from each line
                    assigmentEval.addFunctionFromString(line, count);
                    count ++;}

                String decomposedIntoFunctions = assigmentEval.startEvalauting(); // this drives the evalution, follow the chain of calls to really understand whatgoes on down there

                if (decomposedIntoFunctions.equals("DIVERGENCE")){
                    System.out.println("PASS"); // if theres no error, woohoo, output PASS, otherwise error gets thrown
                    System.out.println("DIVERGENCE");
                }
                else{
                    int result = doOperations(decomposedIntoFunctions);
                    System.out.println("PASS"); // if theres no error, woohoo, output PASS, otherwise error gets thrown
                    System.out.println(result);
                }
            }

            catch (Throwable t){
                System.out.println("FAIL");
                String errorMessage = "Unknown pass error";
                int lineNo = 0;

                try {
                // Check which throwable was passed and output the apropriate error message
                     throw t;
                }

                catch(ParseException e) {
                    errorMessage = intepretParseException(e); // passing the javacc error message into the intepreter to get a more granular result
                    lineNo = e.currentToken.beginLine; // getting the line no of the token
                }

                catch(TokenMgrError e) {
                    Matcher matcher = Pattern.compile("line \\d+").matcher(e.getMessage());
                    if (matcher.find())
                        lineNo = Integer.parseInt(matcher.group().replace("line ", ""));

                    errorMessage = e.toString();
                }

                catch(CustomErrorMessage e) { // this is a custom error message thrown at run-time when dealing with grammer like if the main function is defined or parameters being consistent
                    errorMessage = e.getMessage(); // custom class method
                    lineNo = e.getLine(); // custom class method
                }

                System.err.println(errorMessage);
                System.err.println(lineNo);
            // Catching Throwable is ugly but JavaCC throws Error objects!
            }
    }

        private static String intepretParseException(ParseException e) { // given a parse exception, take the token and give a helpful string representation of the error
            // getting the relevent information from the thrown token
            String str = e.currentToken.image + e.currentToken.next.image;
            int thisToken = e.currentToken.kind;
            int nextToken = e.currentToken.next.kind;

            // Form the set of expected token kinds
            Set<Integer> expected = new HashSet();
            for (int i = 0; i <  e.expectedTokenSequences.length; i++) {
                expected.add(e.expectedTokenSequences[i][0]);
            }

            // Deciphering the parse exception from the thrown token 
            if (thisToken == SPACE && nextToken == EOL)
                return "Unexpected EOL";

            // Consecutive space check
            if (nextToken == SPACE){
                if (thisToken == SPACE){
                    return "Cannot have consecutive spaces, invalid space";
                }
                else{
                  return "Unexpected space";
                }
            }

            // checking for empty function defintion
            if (expected.contains(DEF))
                if (thisToken == EOF && nextToken == EOF)
                    return "Empty input";
                else
                    return "Missing keyword DEF";

            if (( thisToken == FUNCNAME) && expected.contains(SPACE) && nextToken != SPACE)
                return "Incorrect defintion of the function name, instead recieved: " + str;

            if ((thisToken == MAIN ) && expected.contains(SPACE) && nextToken != SPACE)
                return "Incorrect defintion of MAIN name, instead recieved: " + str;

            // function name errors
            if (expected.contains(MAIN) && expected.contains(FUNCNAME)) {
                if (nextToken == DEF)
                    return "Cannot use DEF as a function name";

                return "Missing function name";
            }

            // internal function expression errors
            if ((thisToken == NUM || thisToken == PARAM ) && (expected.contains(PLUS) && expected.contains(MULT) && expected.contains(SPACE)))
                return "Invalid expression inside function definition, expected an operation or an ending of the function definition, was given: " + str;

            if ((thisToken == MULT || thisToken == PLUS ) && (expected.contains(PARAM) && expected.contains(SPACE) && expected.contains(FUNCNAME)))
                return "Invalid expression next to operation inside function definition, was given: " + str;

            // strange function name choices
            if ((thisToken == FUNCNAME || thisToken == MAIN) && expected.contains(SPACE))
                return "Invalid function name " + str;

            // no parameter
            if (expected.contains(PARAM) && expected.size() == 1)
                return "Missing parameter name";

            if (thisToken == PARAM) {
                if (expected.contains(SPACE) && expected.size() == 1) {
                    return "Invalid parameter name " + str;
                } else {
                    return "Invalid parameter reference " + str;
                }
            }

            // formatting errors
            if (expected.contains(LBRACE)) {
                if (nextToken == PARAM) {
                    return "MAIN definition should have no parameter";
                } else {
                    return "Missing {";
                }
            }

            if (thisToken == FUNCNAME && expected.contains(LBRACKET))
                return "Invalid function call " + str;

            if (expected.contains(NUM) && expected.contains(PARAM) && expected.contains(FUNCNAME)) {
                if (nextToken == MAIN)
                    return "Invalid call, MAIN cannot be called in a function expression";

                if (thisToken == LBRACKET) {
                    return "Invalid use of left bracket, only to be used with a function call";

                } else if (thisToken == SPACE) {
                    switch (nextToken) {
                        case EOF:
                            return "Function definition missing expression";

                    }
                }
            }

            // operand ordering error
            if (thisToken == FUNCNAME && (nextToken == PLUS || nextToken == MULT))
                return "Missing operand, was givenn: " + str;

            // catching the uncaught errors missed from above as the sieve tightens we can be more loose 
            if (expected.contains(RBRACKET))
                return "Missing a ), instead recieved: " + str;

            if (expected.contains(RBRACE))
                return "Expecting a } and instead recieved: " + str;

            if (expected.contains(SEMICOLON))
                return "Expecting a ; and instead recieved: " + str;

            switch (nextToken) {
                case EOL:
                    return "Unexpected new line";
                case EOF:
                    return "Unexpected end of file";
                case PARAM:
                    return "Unexpected parameter in main function definition, instead given: " + str;
            }

            if (expected.contains(SPACE) && expected.size() == 1)
                return "Expecting a space by string: " + str;

            if (str.equals(" MAIN"))
                return "Cannot call the MAIN function in this context";
            // final error classification if nothing has been caught 
            return "Unknown string: " + str;
    }

    private static int doOperations(String equation){
        String prevEq = equation;
        String newEq = equation;

        newEq = removeSingleBrackets(newEq); // remove all instances of (number)
        newEq = replaceMult(newEq); // replace all instances of num*num*num to num
        newEq = replacePlus(newEq); // replace all instances of num+num+num with num

        while (!newEq.equals(prevEq)){
            prevEq = newEq;
            newEq = removeSingleBrackets(newEq);
            newEq = replaceMult(newEq);
            newEq = replacePlus(newEq);
        }

       return (Integer.parseInt(newEq));
    }

    public static String removeSingleBrackets(String body){
        ArrayList<String> allMatches = new ArrayList<String>();
        Matcher m = Pattern.compile("\\([0-9]+\\)").matcher(body); //find any number surrounded by brackets like (4) and turn it into 4
        while (m.find()) {
            allMatches.add(m.group());
        }
        for (String num : allMatches){
            String thisNum = num.substring(1,num.length()-1);
            body = body.replace(num,thisNum);
        }
        return body;
    }

    public static String replaceMult(String body){ // find multiplications and replace them with the result
        ArrayList<String> allMatches = new ArrayList<String>(); //find any number surrounded by brackets like (4) and turn it into 4
            Matcher m = Pattern.compile("([0-9]+\\*[0-9]+)+(\\*[0-9])*").matcher(body); //anything like 5*3*3432
            while (m.find()) {
                allMatches.add(m.group());
            }

        for (String chain : allMatches){
            int product = 1;
            ArrayList<String> eachChain = new ArrayList<String>(Arrays.asList(chain.split("\\*")));
            for (String num : eachChain){
                product *= Integer.parseInt(num);
            }
            body = body.replace(chain,String.valueOf(product));
        }
        return body;
    }

    public static String replacePlus(String body){ // find additions  and replace them with the result
        ArrayList<String> allMatches = new ArrayList<String>();
            Matcher m = Pattern.compile("([0-9]+\\+[0-9]+)+(\\+[0-9])*").matcher(body); //anything like 5+3+3432
            while (m.find()) {
                allMatches.add(m.group());
            }

        for (String chain : allMatches){
            int sum = 0;
            ArrayList<String> eachChain = new ArrayList<String>(Arrays.asList(chain.split("\\+")));
            for (String num : eachChain){
                sum += Integer.parseInt(num);
            }
            body = body.replace(chain,String.valueOf(sum));
        }
        return body;
    }

  static final public void Start() throws ParseException, ParseException, CustomErrorMessage {
    splitLines();
    jj_consume_token(0);
    End();
}

  static final public void splitLines() throws ParseException, ParseException, CustomErrorMessage {Token t;
    label_1:
    while (true) {
      jj_consume_token(DEF);
      jj_consume_token(SPACE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MAIN:{
        jj_consume_token(MAIN);
        MF();
        break;
        }
      case FUNCNAME:{
        jj_consume_token(FUNCNAME);
        GF();
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(SPACE);
      jj_consume_token(SEMICOLON);
      jj_consume_token(EOL);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DEF:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
}

  static final public void WHICHFUNC() throws ParseException, ParseException, CustomErrorMessage {
    if (jj_2_1(2)) {
      GF();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SPACE:{
        MF();
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void GF() throws ParseException, ParseException, CustomErrorMessage {Token param;
    jj_consume_token(SPACE);
    param = jj_consume_token(PARAM);
    jj_consume_token(SPACE);
    jj_consume_token(LBRACE);
    jj_consume_token(SPACE);
    EXP(param);
    jj_consume_token(SPACE);
    jj_consume_token(RBRACE);
}

  static final public void MF() throws ParseException, ParseException, CustomErrorMessage {
if (mainDefined) {
            {if (true) throw new ParseException("Main function can only be defined once");}
        } else {
            mainDefined = true;
        }
    jj_consume_token(SPACE);
    jj_consume_token(LBRACE);
    jj_consume_token(SPACE);
    EXPMAIN();
    jj_consume_token(SPACE);
    jj_consume_token(RBRACE);
}

  static final public void EXP(Token p) throws ParseException, ParseException, CustomErrorMessage {Token exactParam;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FUNCNAME:{
      FUNCCALL(p);
      break;
      }
    case NUM:{
      jj_consume_token(NUM);
      break;
      }
    case PARAM:{
      exactParam = jj_consume_token(PARAM);
if (!(exactParam.image).equals(p.image)){
        {if (true) throw new CustomErrorMessage("Expected parameter " + p.image + ", was given, " + exactParam.image + " ", exactParam.beginLine);}
    }
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MULT:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        jj_consume_token(MULT);
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNCNAME:{
        FUNCCALL(p);
        break;
        }
      case NUM:{
        jj_consume_token(NUM);
        break;
        }
      case PARAM:{
        exactParam = jj_consume_token(PARAM);
if (!(exactParam.image).equals(p.image)){ //checking the passed parameter is the same as the one mentioned in the func def
        {if (true) throw new CustomErrorMessage("Expected parameter was: " + p.image + ", was given: " + exactParam.image, exactParam.beginLine);}
    }
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void EXPMAIN() throws ParseException, ParseException, CustomErrorMessage {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM:{
      jj_consume_token(NUM);
      break;
      }
    case FUNCNAME:{
      FUNCCALLMAIN();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MULT:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        jj_consume_token(MULT);
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNCNAME:{
        FUNCCALLMAIN();
        break;
        }
      case NUM:{
        jj_consume_token(NUM);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void FUNCCALL(Token p) throws ParseException, ParseException, CustomErrorMessage {
    jj_consume_token(FUNCNAME);
    jj_consume_token(LBRACKET);
    EXP(p);
    jj_consume_token(RBRACKET);
}

  static final public void FUNCCALLMAIN() throws ParseException, ParseException, CustomErrorMessage {Token t;
    jj_consume_token(FUNCNAME);
    jj_consume_token(LBRACKET);
    EXPMAIN();
    jj_consume_token(RBRACKET);
}

  static final public void End() throws ParseException, ParseException, CustomErrorMessage {
if (!mainDefined) {
        {if (true) throw new CustomErrorMessage("Missing MAIN function",0);}
        }
}

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_3_1()
 {
    if (jj_3R_GF_526_5_4()) return true;
    return false;
  }

  static private boolean jj_3R_GF_526_5_4()
 {
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(PARAM)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AssignmentTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x1080,0x40,0x800,0x3100,0x600,0x600,0x3100,0x1100,0x600,0x600,0x1100,};
	}
  static final private JJCalls[] jj_2_rtns = new JJCalls[1];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Assignment(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Assignment(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new AssignmentTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Assignment(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new AssignmentTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new AssignmentTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Assignment(AssignmentTokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(AssignmentTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[15];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 11; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 15; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 1; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}

class Evaluater{
    private ArrayList<Function> functions;
    private ArrayList<String> allInput;
    private int finalValue; //should store the final value 
    private Stack<Function> stack = new Stack<Function>();
    private boolean diverges = false;

    public Evaluater(){
        functions = new ArrayList<Function>();
        finalValue = finalValue;
        stack = stack;
        diverges = diverges;
    }

    public void checkValidFunctions() throws CustomErrorMessage{ // check if any functions call inexistent functions or function is defined teice
        ArrayList<String> functionNames = new ArrayList<String>();
        for (Function f : functions){
            functionNames.add(f.getName());
        }

        for (int i = 0; i < functionNames.size(); i++){
            String fName = functionNames.get(i);
            functionNames.remove(i);
            if (functionNames.contains(fName)){
                Function thisF = getFunctionByName(fName);
                throw new CustomErrorMessage("Function (" + thisF.getName() + ") is defined more than one", thisF.getLine());
            }
            functionNames.add(i,fName);
        }

        for (Function f : functions){ // go through each defined functions and extract the called functions and check them against the defined ones in functionNames
            ArrayList<String> thisCalledFuncs = f.getCalledFunc();
            if (thisCalledFuncs.size() > 0)
                for (String fName : thisCalledFuncs) {
                    if (!functionNames.contains(fName)){
                        throw new CustomErrorMessage("Function (" + f.getName() + ") calls undefined function (" + fName + ")", f.getLine());
                    }
                }
        }
    }

    public Function getFunctionByName(String name) throws CustomErrorMessage{ // give it a name, it gives you back the function with that name
        for (Function f : functions)
            if (f.getName().equals(name))
                return f;

        throw new CustomErrorMessage("no function called this",0);
    }

    public int totalExtractedFunctionCalls(){ // gets the number of extracted functions to check divergence
        int total = 0;
        for (Function f : functions){
            total += f.extractCalledFunctions().size();
        }
        return total;
    }

    public String startEvalauting() throws ParseException, CustomErrorMessage{
        checkValidFunctions(); // check if any functions call inexistent functions, if not throw error
        int totalExtracted = totalExtractedFunctionCalls();

        Function startPoint = getFunctionByName("MAIN");
        int totalCalls = 0;
        while (startPoint.hasCalledFunctions()){
            ArrayList<String> startCalledFuncs = startPoint.extractCalledFunctions();
            while (startCalledFuncs.size() > 0){
                String firstCF = startCalledFuncs.get(0);
                String bodyOfCalledFunction = startPoint.getBodyOfCalledFunction(firstCF, startPoint.getBody()); // the body of the called function, the parameter to the function 
                String entireInternalFuncCall = firstCF + "(" + bodyOfCalledFunction + ")"; // entire call of the function
                Function actualCalledFunction = getFunctionByName(firstCF); // getting the actual object of the function
                String newBody = actualCalledFunction.replaceParam(bodyOfCalledFunction); // calling this function replacing the paramter with whatever needs replacing
                startPoint.updateBody(startPoint.getBody().replace(entireInternalFuncCall,"(" + newBody + ")")); // replacing the old body with the new decomposed one
                startCalledFuncs = startPoint.extractCalledFunctions();
                totalCalls ++;
                if (totalCalls > totalExtracted + 20) //20 just to be sure
                    return "DIVERGENCE"; // PLM is divergent iff the total no. extracted calls < running total calls
            }
        }
        return startPoint.getBody();
    }
    // this function takes a string like: ADDFOUR x { x+4 }
    // splits it into the relevent parts to make it a function object and then adds it to the list of functions
    public void addFunctionFromString(String func, int lineNo) throws ParseException{
        //initialising these vaiables to be able to grep the fields from the plain text
        String name = "";
        String body = "";
        String namedParam = "";

        //grepping the fields by pattern
        Matcher matcher = Pattern.compile("[A-Z]+").matcher(func);
        if (matcher.find()){
            name = matcher.group();}

        matcher = Pattern.compile("\\{ (.)+ \\}").matcher(func);
        if (matcher.find()){
            body = matcher.group();
            body = body.substring(2,body.length() - 2);
        }

        matcher = Pattern.compile("[a-z]+").matcher(func);
        if (matcher.find()){
            namedParam = matcher.group();}

        Function newFunc = new Function(name, body, namedParam, lineNo); // initialising the object
        functions.add(newFunc); // add the new formed function
    }
}

// all passed functions are passed here for processing
class Function {
    private String name; // name of this function
    private String body;
    private String namedParam;
    private int line;
    private ArrayList<String> calledFunctions; // name of all the called functions within this

    // constructor for when a function is found
    public Function(String givenName, String givenBody, String givenNamedParam, int givenLine){
        name = givenName;
        body = givenBody;
        line = givenLine;
        namedParam = givenNamedParam;
        calledFunctions = new ArrayList<String>();
        calledFunctions =  extractCalledFunctions();
    }

    // constructor when it is being processed in the stack
    public Function(String givenName, String givenBody){
        name = givenName;
        body = givenBody;
        calledFunctions = new ArrayList<String>();
        calledFunctions =  extractCalledFunctions();
    }

    public String replaceParam(String givenFuncBody){
        return (body.replace(namedParam,"(" + givenFuncBody + ")")); //adding brackets for distributivity law etc
    }

    public String getBodyOfCalledFunction(String givenCalledFunction, String bodyToFunc){ // helper function to replace a called function, replace a param with a body
        int leftBracket = 1; //  count the number of left and right brackets and once they equal the paramter has ended
        int rightBracket = 0;
        int bodyStart = bodyToFunc.indexOf(givenCalledFunction) + givenCalledFunction.length() + 1;
        int index = bodyStart;

        while (leftBracket != rightBracket){
            if (Character.toString(bodyToFunc.charAt(index)).equals("("))
                leftBracket++;
            if (Character.toString(bodyToFunc.charAt(index)).equals(")"))
                rightBracket++;

            index ++;
        }
        //System.out.println(givenCalledFunction + " " + bodyToFunc + " " + bodyToFunc.substring(bodyStart,index-1));
        return bodyToFunc.substring(bodyStart,index-1);
    }

    public ArrayList<String> extractCalledFunctions(){ //getting the called functions
        ArrayList<String> allMatches = new ArrayList<String>();

        Matcher m = Pattern.compile("[A-Z]+").matcher(getBody());
        while (m.find()) {
            allMatches.add(m.group());
        }

        return allMatches;

    }

    public boolean hasCalledFunctions(){
        return (extractCalledFunctions().size() != 0);
    }

    // when this is called by the master functions class, it should:
    // 1) take an internal called funtion
    // 2) find the function with that name
    // 3) call replaceParam on that function with the passed param 
    // 4) then call replaceFuncCall on this function, giving back a decomposed function
    public String replaceFuncCall(String original, String replacer){
        return body.replace(original,replacer);
    }
    // getter functions
    public String getName(){return name;}

    public String getBody(){return body;}

    public String getNamedParam(){return namedParam;}

    public int getLine(){return line;}

    public ArrayList<String> getCalledFunc(){return calledFunctions;}

    public void updateBody(String newBody){body = newBody;}
}

class CustomErrorMessage extends Throwable {
    private String message;
    private int line;

    // Constructor, not really 
    public CustomErrorMessage(String givenMessage, int givenLine) {
        message =  givenMessage;
        line =  givenLine;
    }

    public String getMessage() {
        return message;
    }

    public int getLine() {
        return line;
    }
}
