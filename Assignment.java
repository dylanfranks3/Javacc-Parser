/* Assignment.java */
/* Generated By:JavaCC: Do not edit this line. Assignment.java */
import java.util.*; //library import
import java.util.regex.Pattern;
import java.util.regex.Matcher;


public class Assignment implements AssignmentConstants {
    private static boolean mainDefined = false; //checking whether there is a main function, to make sure only defined once, and importantly defined

    public static void main(String[] args) throws ParseException, TokenMgrError {
            try{
                Assignment parser = new Assignment(System.in); // give whatever is inputted to the parser
                parser.Start(); // start the grammer checking

                System.out.println("PASS"); // if theres no error, woohoo, output PASS, otherwise error gets thrown
                System.out.println("TODO show result");

                Evaluater assigmentEval = new Evaluater() ;
                String testFunc = "ADDFOUR x { x+4 }";
                assigmentEval.addFunctionFromString(testFunc);



            }

            catch (Throwable t){
                System.out.println("FAIL");
                String errorMessage = "Unknown pass error";
                int lineNo = 0;

                try {
                // Check which throwable was passed and output the apropriate error message
                     throw t;
                }

                catch(ParseException e) {
                    errorMessage = intepretParseException(e); // passing the javacc error message into the intepreter to get a more granular result
                    lineNo = e.currentToken.beginLine; // getting the line no of the token
                }

                catch(TokenMgrError e) {
                    Matcher matcher = Pattern.compile("line \\d+").matcher(e.getMessage());
                    if (matcher.find())
                        lineNo = Integer.parseInt(matcher.group().replace("line ", ""));


                    errorMessage = e.toString();
                }

                catch(CustomErrorMessage e) { // this is a custom error message thrown at run-time when dealing with grammer like if the main function is defined or parameters being consistent
                    errorMessage = e.getMessage(); // custom class method
                    lineNo = e.getLine(); // custom class method
                }


                System.err.println(errorMessage);
                System.err.println(lineNo);

            // Catching Throwable is ugly but JavaCC throws Error objects!
            }
    }

        private static String intepretParseException(ParseException e) { // given a parse exception, take the token and give a helpful string representation of the error
            // getting the relevent information from the thrown token
            String str = e.currentToken.image + e.currentToken.next.image;
            int thisToken = e.currentToken.kind;
            int nextToken = e.currentToken.next.kind;

            // Form the set of expected token kinds
            Set<Integer> expected = new HashSet();
            for (int i = 0; i <  e.expectedTokenSequences.length; i++) {
                expected.add(e.expectedTokenSequences[i][0]);
            }

            //System.out.println("\n" + "thisToken: " + thisToken + "\n" + "nextToken: " + nextToken + "\n" + "Expected: " + expected.toString() + "\n");

            // Deciphering the parse exception from the thrown token 
            if (thisToken == SPACE && nextToken == EOL)
                return "Unexpected EOL";


            // Consecutive space check
            if (nextToken == SPACE){
                if (thisToken == SPACE){
                    return "Cannot have consecutive spaces, invalid space";
                }
                else{
                  return "Unexpected space";
                }
            }

            // checking for empty function defintion
            if (expected.contains(DEF))
                if (thisToken == EOF && nextToken == EOF)
                    return "Empty input";
                else
                    return "Missing keyword DEF";

            if (( thisToken == FUNCNAME) && expected.contains(SPACE) && nextToken != SPACE)
                return "Incorrect defintion of function, correct the formatting of the function name, instead recieved: " + str;

            if ((thisToken == MAIN ) && expected.contains(SPACE) && nextToken != SPACE)
                return "Incorrect defintion of MAIN, correct the formatting of the function name, instead recieved: " + str;


            // function name errors
            if (expected.contains(MAIN) && expected.contains(FUNCNAME)) {
                if (nextToken == DEF)
                    return "Cannot use DEF as a function name";

                return "Missing function name";
            }

            // internal function expression errors
            if ((thisToken == NUM || thisToken == PARAM ) && (expected.contains(PLUS) && expected.contains(MULT) && expected.contains(SPACE)))
                return "Invalid expression inside function definition, expected an operation or an ending of the function definition, was given: " + str;

            if ((thisToken == MULT || thisToken == PLUS ) && (expected.contains(PARAM) && expected.contains(SPACE) && expected.contains(FUNCNAME)))
                return "Invalid expression next to operation inside function definition, was given: " + str;

            // strange function name choices
            if ((thisToken == FUNCNAME || thisToken == MAIN) && expected.contains(SPACE))
                return "Invalid function name " + str;

            // no parameter
            if (expected.contains(PARAM) && expected.size() == 1)
                return "Missing parameter name";

            if (thisToken == PARAM) {
                if (expected.contains(SPACE) && expected.size() == 1) {
                    return "Invalid parameter name " + str;
                } else {
                    return "Invalid parameter reference " + str;
                }
            }

            // formatting errors
            if (expected.contains(LBRACE)) {
                if (nextToken == PARAM) {
                    return "MAIN definition should have no parameter";
                } else {
                    return "Missing {";
                }
            }

            if (thisToken == FUNCNAME && expected.contains(LBRACKET))
                return "Invalid function call " + str;

            if (expected.contains(NUM) && expected.contains(PARAM) && expected.contains(FUNCNAME)) {
                if (nextToken == MAIN)
                    return "Invalid call, MAIN cannot be called in a function expression";

                if (thisToken == LBRACKET) {
                    return "Invalid use of left bracket, only to be used with a function call";

                } else if (thisToken == SPACE) {
                    switch (nextToken) {
                        case EOF:
                            return "Function definition missing expression";

                    }
                }
            }

            // operand ordering error
            if (thisToken == FUNCNAME && (nextToken == PLUS || nextToken == MULT))
                return "Missing operand, was givenn: " + str;

            // catching the uncaught errors missed from above as the sieve tightens we can be more loose 
            if (expected.contains(RBRACKET))
                return "Missing a ), instead recieved: " + str;

            if (expected.contains(RBRACE))
                return "Expecting a } and instead recieved: " + str;

            if (expected.contains(SEMICOLON))
                return "Expecting a ; and instead recieved: " + str;



            switch (nextToken) {
                case EOL:
                    return "Unexpected new line";
                case EOF:
                    return "Unexpected end of file";
                case PARAM:
                    return "Unexpected parameter in main function definition, instead given: " + str;
            }

            // final error classification if nothing has been caught 
            return "Unknown string: " + str;
    }

    // checking if a string contains a lowercase char, purpose for checking main function line def 
    private static boolean containsPARAM(String expression) {
        char ch;
        for(int i=0;i < expression.length();i++) {
            ch = expression.charAt(i);
            if(!Character.isDigit(ch)) {
                if (Character.isLowerCase(ch)) {
                    return true;
                }
            }
        }
        return false;
    }

  static final public void Start() throws ParseException, ParseException, CustomErrorMessage {
    splitLines();
    jj_consume_token(0);
    End();
}

  static final public void splitLines() throws ParseException, ParseException, CustomErrorMessage {
    label_1:
    while (true) {
      jj_consume_token(DEF);
      jj_consume_token(SPACE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MAIN:{
        jj_consume_token(MAIN);
        MF();
        break;
        }
      case FUNCNAME:{
        jj_consume_token(FUNCNAME);
        GF();
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(SPACE);
      jj_consume_token(SEMICOLON);
      jj_consume_token(EOL);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DEF:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
}

  static final public void WHICHFUNC() throws ParseException, ParseException, CustomErrorMessage {
    if (jj_2_1(2)) {
      GF();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SPACE:{
        MF();
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void GF() throws ParseException, ParseException, CustomErrorMessage {Token param;
    jj_consume_token(SPACE);
    param = jj_consume_token(PARAM);
    jj_consume_token(SPACE);
    jj_consume_token(LBRACE);
    jj_consume_token(SPACE);
    EXP(param);
    jj_consume_token(SPACE);
    jj_consume_token(RBRACE);
}

  static final public void MF() throws ParseException, ParseException, CustomErrorMessage {
if (mainDefined) {
            {if (true) throw new ParseException("Main function can only be defined once");}
        } else {
            mainDefined = true;
        }
    jj_consume_token(SPACE);
    jj_consume_token(LBRACE);
    jj_consume_token(SPACE);
    EXPMAIN();
    jj_consume_token(SPACE);
    jj_consume_token(RBRACE);
}

  static final public void EXP(Token p) throws ParseException, ParseException, CustomErrorMessage {Token exactParam;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FUNCNAME:{
      FUNCCALL(p);
      break;
      }
    case NUM:{
      jj_consume_token(NUM);
      break;
      }
    case PARAM:{
      exactParam = jj_consume_token(PARAM);
if (!(exactParam.image).equals(p.image)){
        {if (true) throw new CustomErrorMessage("Expected parameter " + p.image + ", was given, " + exactParam.image + " ", exactParam.beginLine);}
    }
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MULT:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        jj_consume_token(MULT);
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNCNAME:{
        FUNCCALL(p);
        break;
        }
      case NUM:{
        jj_consume_token(NUM);
        break;
        }
      case PARAM:{
        exactParam = jj_consume_token(PARAM);
if (!(exactParam.image).equals(p.image)){ //checking the passed parameter is the same as the one mentioned in the func def
        {if (true) throw new CustomErrorMessage("Expected parameter was: " + p.image + ", was given: " + exactParam.image, exactParam.beginLine);}
    }
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void EXPMAIN() throws ParseException, ParseException, CustomErrorMessage {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM:{
      jj_consume_token(NUM);
      break;
      }
    case FUNCNAME:{
      FUNCCALLMAIN();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MULT:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        jj_consume_token(MULT);
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNCNAME:{
        FUNCCALLMAIN();
        break;
        }
      case NUM:{
        jj_consume_token(NUM);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void FUNCCALL(Token p) throws ParseException, ParseException, CustomErrorMessage {
    jj_consume_token(FUNCNAME);
    jj_consume_token(LBRACKET);
    EXP(p);
    jj_consume_token(RBRACKET);
}

  static final public void FUNCCALLMAIN() throws ParseException, ParseException, CustomErrorMessage {Token t;
    jj_consume_token(FUNCNAME);
    jj_consume_token(LBRACKET);
    EXPMAIN();
    jj_consume_token(RBRACKET);
}

  static final public void End() throws ParseException, ParseException, CustomErrorMessage {
if (!mainDefined) {
        {if (true) throw new CustomErrorMessage("Missing MAIN function",0);}
        }
}

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_3_1()
 {
    if (jj_3R_GF_371_5_4()) return true;
    return false;
  }

  static private boolean jj_3R_GF_371_5_4()
 {
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(PARAM)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AssignmentTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x1080,0x40,0x800,0x3100,0x600,0x600,0x3100,0x1100,0x600,0x600,0x1100,};
	}
  static final private JJCalls[] jj_2_rtns = new JJCalls[1];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Assignment(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Assignment(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new AssignmentTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Assignment(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new AssignmentTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new AssignmentTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Assignment(AssignmentTokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(AssignmentTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[15];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 11; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 15; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 1; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}

class Evaluater{
    private Function[] functions;
    private int finalValue;
    private Stack<Function> stack = new Stack<Function>();
    private boolean diverges = false;


    // this function takes a string like: ADDFOUR x { x+4 }
    // splits it into the relevent parts to make it a function object and then adds it to the list of functions


    public void addFunctionFromString(String func){ // should look like: 
        // filtering the parts of the function structure
      //  Pattern namePattern = Pattern.compile("[A-Z]+");
      //  Matcher nameMatcher = namePattern.matcher(func);
      //  System.out.println(nameMatcher.group());
        String name = "";
        String body = "";
        String namedParam = "";

        Matcher matcher = Pattern.compile("[A-Z]+").matcher(func);
        if (matcher.find()){
            name = matcher.group();}

        matcher = Pattern.compile("\\{ (.)+ \\}").matcher(func);
        if (matcher.find()){
            body = matcher.group();}

        matcher = Pattern.compile("[a-z]+").matcher(func);
        if (matcher.find()){
            namedParam = matcher.group();}


        System.out.println("\nname: " + name + "\nbody: " + body + "\nnamedparam: " + namedParam +"\n");

    }






}

// all passed functions are passed here for processing
class Function {
    private String name; // name of this function
    private String body;
    private String namedParam;
    private String[] calledFunctions; // name of all the called functions within this

    // constructor for when a function is found
    public Function(String givenName, String givenBody, String givenNamedParam){
        name = givenName;
        body = givenBody;
        namedParam = givenNamedParam;
        calledFunctions = extractCalledFunctions();
    }

    // constructor when it is being processed in the stack
    public Function(String givenName, String givenBody){
        name = givenName;
        body = givenBody;
        calledFunctions = extractCalledFunctions();
    }

    public String replaceParam(String givenFuncBody){
        return (body.replace(namedParam,givenFuncBody));
    }

    public String[] extractCalledFunctions(){ //getting the called functions 
        String[] substrings = body.split("[A-Z]+");
        return substrings;
    }

    public boolean hasCalledFunctions(){
        return (extractCalledFunctions().length == 0);
    }

    // when this is called by the master functions class, it should:
    // 1) take an internal called funtion
    // 2) find the function with that name
    // 3) call replaceParam on that function with the passed param 
    // 4) then call replaceFuncCall on this function, giving back a decomposed function
    public String replaceFuncCall(String original, String replacer){
        return body.replace(original,replacer);

    }

    // getter functions
    public String getName(){return name;}

    public String getBody(){return body;}

    public String getNamedParam(){return namedParam;}

    public String[] getCalledFunc(){return calledFunctions;}

}


class CustomErrorMessage extends Throwable {
    private String message;
    private int line;

    // Constructor, not really 
    public CustomErrorMessage(String givenMessage, int givenLine) {
        message =  givenMessage;
        line =  givenLine;
    }

    public String getMessage() {
        return message;
    }

    public int getLine() {
        return line;
    }
}
